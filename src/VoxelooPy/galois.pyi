from typing import Generic, TypeVar, Tuple, Union, List, Any
import numpy as np

T = TypeVar('T', bool, int, float)
RGBA = Tuple[int, int, int, int]

class Transform:
    permute: np.ndarray
    reflect: np.ndarray
    shift: np.ndarray

class MaterialBuffer:
    rank: int
    data: Any

class CheckboardPosition:
    White: int
    Black: int

class MoistureLevel:
    Zero: int
    Low: int
    Moderate: int
    High: int
    Full: int

class Samples:
    count: int
    offsets: Any

class Sampler:
    def size(self) -> int: ...
    def get(self, index: int) -> Any: ...

class Index:
    def get_sampler(self) -> Sampler: ...
    def dumps(self) -> bytes: ...
    def loads(self, data: bytes) -> None: ...

class IndexBuilder:
    def __init__(self, arg0: int, arg1: int) -> None: ...
    def add_block(self, arg0: Any) -> None: ...
    def build(self) -> Index: ...

class QuadVertex:
    def __init__(self, pos: Tuple[float, float, float], normal: Tuple[float, float, float], uv: Tuple[float, float], arg3: float, arg4: int) -> None: ...
    def pos(self) -> Tuple[float, float, float]: ...
    def normal(self) -> Tuple[float, float, float]: ...
    def uv(self) -> Tuple[float, float]: ...
    def texture(self) -> int: ...

class Quads:
    vertices: List[QuadVertex]
    indices: List[int]

class GeometryBuffer:
    vertices: Any
    indices: Any
    def vertex_data(self) -> memoryview: ...
    def index_data(self) -> memoryview: ...

class Vertex:
    pos: Tuple[float, float, float]
    normal: Tuple[float, float, float]
    uv: Tuple[float, float]

class Texture:
    def shape(self) -> Tuple[int, int]: ...
    @property
    def data(self) -> np.ndarray: ...
    @staticmethod
    def fromarray(array: np.ndarray) -> 'Texture': ...

class Mesh:
    texture: Texture
    def vertex_data(self) -> memoryview: ...
    def index_data(self) -> memoryview: ...

class CombinedMesh:
    blocks: Any
    florae: Any
    glass: Any

class Buffer:
    rank: int
    data: Any

class StorageBuffer:
    def shape(self) -> Tuple[int, int, int]: ...
    data: Any
    def view(self) -> memoryview: ...

class Level:
    MACRO: int
    MICRO: int

class Quad:
    def pos(self) -> Tuple[int, int, int]: ...
    lvl: Level

class Box:
    def pos(self) -> Tuple[int, int, int]: ...
    len: int

class Edge:
    def v0(self) -> Tuple[float, float, float]: ...
    def v1(self) -> Tuple[float, float, float]: ...

class WireframeMesh:
    def vertex_data(self) -> memoryview: ...
    def index_data(self) -> memoryview: ...

# Module functions
def clear(tensor: Any, mask: Any) -> Any: ...
def slice(tensor: Any, mask: Any) -> Any: ...
def merge(left: Any, right: Any) -> Any: ...
def write(tensor: Any, mask: Any, value: T) -> Any: ...
def apply(tensor: Any, transform: Transform) -> Any: ...
def shift(transform: Transform) -> Transform: ...
def permute(transform: Transform) -> Transform: ...
def reflect(transform: Transform) -> Transform: ...
def compose(t1: Transform, t2: Transform) -> Transform: ...
def to_surface_tensor(arg0: Any) -> Any: ...
def to_block_sample_tensor(arg0: Any) -> Any: ...
def to_material_buffer(arg0: Any) -> MaterialBuffer: ...
def to_geometry(tensor: Any, growth: Any, muck: Any, index: Any) -> GeometryBuffer: ...
def to_index(arg0: Any) -> Any: ...
def to_tensor(arg0: Any) -> Any: ...
def to_mesh(arg0: Any) -> Mesh: ...
def to_wireframe_mesh(arg0: Any) -> WireframeMesh: ...
def to_buffer(tensor: Any, isomorphisms: Any) -> Buffer: ...
def is_valid_block_id(arg0: int) -> bool: ...
def from_block_id(arg0: int) -> Any: ...
def to_blocks(arg0: Any) -> Any: ...
def is_valid_flora_id(arg0: int) -> bool: ...
def from_flora_id(arg0: int) -> Any: ...
def to_florae(arg0: Any) -> Any: ...
def is_valid_glass_id(arg0: int) -> bool: ...
def from_glass_id(arg0: int) -> Any: ...
def to_glass(arg0: Any) -> Any: ...
def to_surface(tensor: Any) -> Any: ...
def to_geometry(tensor: Any) -> GeometryBuffer: ...